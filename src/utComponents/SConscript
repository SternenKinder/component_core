import sys
import glob
import os.path

# import variables from other scons files
Import( '*' )

# HOW TO BUILD (A) LIBRAR-Y/IES FROM A MODULE
# Building libraries from modules should be consistent for each module.
# Use the following scheme for each new library created:
#
# a) Define the src-subdirectories for which the library should be compiled
#    and glob all files in there
# b) Define a [LIBRARY]_options variable for the library containing all dependencies
#    from other libraries. Create a clone from the master environment and add those options.
# c) WINDOWS ONLY: Create a header file which implements dll interface functionality
#    dependent from a [LIBRARY]_DLL define. If the define is set, the dll should be exported,
#    if not, the dll should be imported. Set the define in the preprocessor options for the environment.
# d) Build the library!
# e) Remove all entries for (at least) the LIBS and LIBPATH keys in the options and
#    add only the newly-compiled library as a dependcy. This will avoid multiple includes
#    of libraries. Also verify that the import/export-switch define is not set.
# f) Export the options so that other libraries can base on this library.
#
# The use of options and possibility to export them makes hierarchical build environments
# obsolete. Avoid exporting new environments to the build system.


# a)
if not have_utdataflow:
	print "Dataflow module missing -- not building components"
	result = False
	Return("result")
	
env = masterEnv.Clone()

# automatically glob files from subdirectories
comp_sources = globSourceFiles( '*.cpp' )

# remove components that require a not present feature
if not have_lapack:
	for src in [ 'RotHecKalmanFilter.cpp', 'RotOnlyKalmanFilter.cpp', 'HomogeneousMatrixEstimation.cpp', 'DecomposeProjectionMatrix.cpp', 'SPAAM.cpp', 'AbsoluteOrientation.cpp', 'AbsoluteOrientationRANSAC.cpp', 'OnlineRotHec.cpp', '2D3DPoseEstimation.cpp', 'HandEyeCalibration.cpp', 'PoseKalmanFilter.cpp', 'TipCalibration.cpp', 'MultipleCameraPoseOptimization.cpp' ]:
		comp_sources.remove( src );


# b)	
# setup compiler and linker flags
# Merge all options in one "ubitrack" option. Note that some options might be empty if its module is not available	
component_options = mergeOptions( utdataflow_all_options)

env.AppendUnique( **component_options )
		
# c)
# nothing to do this time

# d)	
libs = setupComponentBuild(env, comp_sources, 'components')

# e)
utcomponents_options = {}
utcomponents_options[ 'CPPPATH' ] =  [ os.path.join( getCurrentPath(), '..') ]
utcomponents_options[ 'LIBS' ] = []#libs
utcomponents_options[ 'LIBPATH' ] = [ install_library_prefix ]

have_utcomponents = libs != 0

# f)
Export( 'utcomponents_options', 'have_utcomponents' )

# also create a visual studio project for the library	
sources = globSourceFiles( '*.cpp' )
headers = globSourceFiles( '*.h' )
createVisualStudioProject(env, sources, headers, 'utComponents')
